-- TABLES

--Holds user information
CREATE TABLE Users (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR UNIQUE NOT NULL,
    password VARCHAR(256) NOT NULL,
    firstname VARCHAR(256) NOT NULL,
    lastname VARCHAR(256) NOT NULL,
    street1 VARCHAR(256) NOT NULL, 
    street2 VARCHAR(256), 
    city VARCHAR(256) NOT NULL, 
    state VARCHAR(256) NOT NULL, 
    zip VARCHAR(5) NOT NULL
);

--Track when user adds or subtracts money to/from their account
CREATE TABLE Funding (
    id INT NOT NULL, 
    FOREIGN KEY (id) REFERENCES Users(id),
    transactionDT timestamp without time zone NOT NULL DEFAULT (current_timestamp AT  TIME ZONE 'UTC'),
    amount FLOAT NOT NULL DEFAULT (0),
    PRIMARY KEY(id, transactionDT)
);

-- Keeps track of which users are sellers
CREATE TABLE Seller (
    SellerID INT NOT NULL PRIMARY KEY, 
    FOREIGN KEY (SellerID) REFERENCES Users(id)
);

-- Table to store product offerings and their inventory status by seller
CREATE TABLE Products (
    productID INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(256) UNIQUE NOT NULL,
    description VARCHAR(256) NOT NULL,
    category VARCHAR(256) NOT NULL,
    unitPrice DECIMAL(65,2) NOT NULL,
    CHECK(unitPrice > 0.0),
    Inventory INT NOT NULL,
    CHECK(Inventory > -1),
    SellerID INT NOT NULL,
    FOREIGN KEY(SellerID) REFERENCES Seller(SellerID),
    image VARCHAR(256) NOT NULL
);

-- Table to keep track of purchases/order history and the price at which units were purchased
-- Makes hard copy of unit price since a product's price can change (i.e. doesn't reference products for price)
CREATE TABLE Purchases (
    SellerID INT NOT NULL,
    FOREIGN KEY (SellerID) REFERENCES Seller(SellerID),
    uid INT NOT NULL,
    FOREIGN KEY (uid) REFERENCES Users(id),
    pid INT NOT NULL,
    FOREIGN KEY (pid) REFERENCES Products(productID),
    orderDateTime timestamp without time zone NOT NULL DEFAULT (current_timestamp AT  TIME ZONE 'UTC'),
    finalUnitPrice FLOAT ,
	quantity INT NOT NULL,
    CHECK(quantity >= 1), 
    fufullmentstatus VARCHAR(256) NOT NULL, 
    fulfillment_datetime timestamp without time zone, 
    PRIMARY KEY(SellerID, uid, pid, orderDateTime)
);
 
-- Keeps track of what items are in a given user's cart
CREATE TABLE Cart (
	uid INT NOT NULL REFERENCES USERS(id),
	pid INT NOT NULL,
	sid INT NOT NULL REFERENCES SELLER(SellerId),
	quantity INT NOT NULL,
	CHECK(quantity >= 1),
	PRIMARY KEY(uid, pid, sid)
);
 
-- Stores user reviews on a product
CREATE TABLE ProductReview (
	uid INT NOT NULL REFERENCES USERS(id),
	pid INT NOT NULL REFERENCES PRODUCTS(productID),
	rating FLOAT NOT NULL,
	CHECK (rating >= 1.0 AND rating <= 5.0),
    numDownVotes INT NOT NULL CHECK(numDownVotes>-1),
    numUpVotes INT NOT NULL CHECK(numUpVotes>-1),
	review VARCHAR(256),
	DateTime timestamp without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
	PRIMARY KEY(uid, pid)
);
 
-- Stores user's reviews on a given seller
CREATE TABLE SellerReview (
	uid INT NOT NULL REFERENCES USERS(id),
	sid INT NOT NULL REFERENCES SELLER(SellerId),
	rating FLOAT NOT NULL,
	CHECK(rating >= 1.0 AND rating <= 5.0),
    numDownVotes INT NOT NULL CHECK(numDownVotes>-1),
    numUpVotes INT NOT NULL CHECK(numUpVotes>-1),
	review VARCHAR(256),
	DateTime timestamp without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
	PRIMARY KEY(uid, sid)
	
);

-- Stores conversations between seller and user 
CREATE TABLE Messages (
	uid INT NOT NULL REFERENCES USERS(id),
	sid INT NOT NULL REFERENCES SELLER(SellerId),
    sender VARCHAR(256), 
	message VARCHAR(256),
	MessageDateTime timestamp without time zone NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
	PRIMARY KEY(uid, sid, MessageDateTime)
);
 
-- TRIGGERS 

-- Ensures there is enough inventory for the user to purchase the item
CREATE FUNCTION TF_Inventory() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS(SELECT * FROM Products, Purchases
        WHERE productID = NEW.uid AND Purchases.SellerID = NEW.SellerID AND inventory- quantity<0) THEN
        RAISE EXCEPTION '% does not have the desired amount in stock', NEW.uid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
 
CREATE TRIGGER TF_Inventory  
BEFORE INSERT OR UPDATE ON Purchases
  FOR EACH ROW  EXECUTE PROCEDURE TF_Inventory();

-- Checks to see if user can message seller (condition is that must have made a purchase from them)
CREATE FUNCTION TF_MessagingSeller() RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM Purchases
        WHERE Purchases.uid = NEW.uid AND Purchases.sid = NEW.SellerID) THEN
        RAISE EXCEPTION 'User has not made a purchase from this seller, and thus cannot message them';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
 
 
CREATE TRIGGER TF_MessagingSeller 
BEFORE INSERT OR UPDATE ON Messages
  FOR EACH ROW  EXECUTE PROCEDURE TF_MessagingSeller();

 -- Ensures that customer actually bought product from seller before review
CREATE FUNCTION TF_SellerReview() RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM Purchases
        WHERE uid = NEW.uid AND sid = NEW.sid) THEN
        RAISE EXCEPTION '% has not purchased a product from %', NEW.uid, NEW.sid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER TG_SellerReview
BEFORE INSERT ON SellerReview
    FOR EACH ROW
    EXECUTE PROCEDURE TF_SellerReview();

 -- Ensures that customer actually bought product before review
CREATE FUNCTION TF_ProductReview() RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM Purchases
        WHERE uid = NEW.uid AND pid = NEW.pid) THEN
        RAISE EXCEPTION '% has not purchased product %', NEW.uid, NEW.pid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TF_ProductReview
BEFORE INSERT ON ProductReview
    FOR EACH ROW
    EXECUTE PROCEDURE TF_ProductReview();


-- Ensures that customer has not already submitted a product review
CREATE FUNCTION TF_DoubleProductReview() RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM ProductReview
        WHERE uid = NEW.uid AND pid = NEW.pid) THEN
        RAISE EXCEPTION '% has already left a review for product %', NEW.uid, NEW.pid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TF_DoubleProductReview
BEFORE INSERT ON ProductReview
    FOR EACH ROW
    EXECUTE PROCEDURE TF_DoubleProductReview();

-- Ensures that customer has not already submitted a seller review
CREATE FUNCTION TF_DoubleSellerReview() RETURNS TRIGGER AS $$
BEGIN
    IF NOT EXISTS(SELECT * FROM SellerReview
        WHERE uid = NEW.uid AND sid = NEW.sid) THEN
        RAISE EXCEPTION '% has already left a review for seller %', NEW.uid, NEW.sid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TF_DoubleSellerReview
BEFORE INSERT ON SellerReview
    FOR EACH ROW
    EXECUTE PROCEDURE TF_DoubleSellerReview();

-- Raises error if quantity of an item existing in someones cart is no longer valid because someone
 -- else purchased the item and the inventory is now less than the amount in the user's cart
CREATE FUNCTION TF_validCartQuantity() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS(SELECT * FROM Cart, Products
        WHERE Cart.pid = Products.productID AND Cart.sid = Products.SellerID AND
            Products.productID= NEW.pid AND Products.SellerID = NEW.SellerID AND
            Cart.quantity > Products.inventory) THEN
        RAISE EXCEPTION '% can no longer purchase % units of %', Cart.uid, Cart.quantity, Cart.pid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_validCartQuantity
AFTER INSERT ON Purchases
    FOR EACH ROW
    EXECUTE PROCEDURE TF_validCartQuantity();

-- Trigger to update the product inventory after a purchase
CREATE FUNCTION TF_updateInventory() RETURNS TRIGGER AS $$
BEGIN
    UPDATE Products set inventory = inventory - NEW.quantity where productID = NEW.pid and SellerID = new.SellerID;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_updateInventory
AFTER INSERT ON Purchases
    FOR EACH ROW
    EXECUTE PROCEDURE TF_updateInventory();

-- Trigger to ensure user has enough balance for purchase to be made
CREATE FUNCTION TF_balance() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS(SELECT * FROM userBalance WHERE 
        id = NEW.uid AND amount < (NEW.quantity * NEW.finalUnitPrice)) THEN
        RAISE EXCEPTION 'User % has insufficient funds for purchase', NEW.uid;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_balance
BEFORE INSERT ON Purchases
    FOR EACH ROW
    EXECUTE PROCEDURE TF_balance();

-- Trigger to ensure user has enough balance to deduct funds
CREATE FUNCTION TF_funds() RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS(SELECT * FROM userBalance WHERE 
        id = NEW.id AND amount < -(NEW.amount)) THEN
        RAISE EXCEPTION 'You cannot deduct more funds than you have';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER TG_deductfunds
BEFORE INSERT ON Funding
    FOR EACH ROW
    EXECUTE PROCEDURE TF_funds();

-- VIEWS

--  List total cost of all items currently in each users cart
CREATE VIEW cartTotalPrice(uid, totalPrice) AS
    SELECT t2.uid, SUM(t2.itemTotal) AS totalPrice FROM 
        (SELECT Cart.uid, (Cart.quantity * t1.unitPrice) AS itemTotal FROM Cart JOIN 
            (SELECT productId, unitPrice FROM Products) AS t1 ON Cart.pid = t1.productId) AS t2
    GROUP BY t2.uid;
    
--  Create view page for buyer profile
CREATE VIEW sellerpage(ID) AS
    SELECT sellerID, email, street1, street2, city, state, zip 
    FROM Seller, Users 
    WHERE id = sellerID;

--  Create view page to get each user's current balance
CREATE VIEW userBalance(id, amount) AS
    SELECT Users.id, COALESCE(balances.balance, 0) AS amount FROM Users LEFT JOIN 
        (SELECT fund.id, (fund.totFund - COALESCE(purch.totPurch, 0)) AS balance FROM 
            (SELECT id, SUM(amount) AS totFund FROM Funding GROUP BY id) AS fund 
        FULL OUTER JOIN 
            (SELECT uid, SUM(finalUnitPrice * quantity) AS totPurch FROM Purchases GROUP BY uid) AS purch
        ON fund.id = purch.uid) AS balances
    ON Users.id = balances.id;

